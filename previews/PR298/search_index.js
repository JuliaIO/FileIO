var documenterSearchIndex = {"docs":
[{"location":"implementing/#Implementing-loaders/savers","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"","category":"section"},{"location":"implementing/#Principle-of-operation:-module-qualification","page":"Implementing loaders/savers","title":"Principle of operation: module qualification","text":"","category":"section"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"When FileIO detects that a file or stream should be handled by a particular package, it will try to call private methods in that package for processing the request. For example, suppose you have created a package called MyFileFormat to handle files of a particular format; then load(\"somefile.myfmt\") for a suitable file will cause FileIO to:","category":"page"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"attempt to load your package MyFileFormat using Base.require(id::PkgId), where a PkgId combines the name and UUID that you supplied via add_format\ncall MyFileFormat.load(file) where file is File.","category":"page"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"A crucial point is that MyFileFormat.load does not extend FileIO.load: it is a private function defined in module MyFileFormat. This is important for ensuring that single formats can be supported by multiple packages; if two or more packages specialized File.load for file::File{format\"MYFORMAT\"}), then","category":"page"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"using Pkg1, Pkg2   # two packages both inappropriately extending FileIO.load","category":"page"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"would cause all such loads to be handled by Pkg2, but","category":"page"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"using Pkg2, Pkg1","category":"page"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"would cause them to be handled by Pkg1. This would make loading incredibly brittle. For that reason, it is essential to keep load private to your package and let FileIO call it by module-qualification.","category":"page"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"The same applies to save, loadstreaming, and savestreaming.","category":"page"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"If you run into a naming conflict with the load and save functions (for example, you already have another function in your package that has one of these names), you can instead name your loaders fileio_load, fileio_save etc. Note that you cannot mix and match these styles: either all your loaders have to be named load, or all of them should be called fileio_load, but you cannot use both conventions in one module.","category":"page"},{"location":"implementing/#All-at-once-I/O:-implementing-load-and-save","page":"Implementing loaders/savers","title":"All-at-once I/O: implementing load and save","text":"","category":"section"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"In your package, write code like the following:","category":"page"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"module MyFileFormat\n\nusing FileIO\n\n# Again, this is a *private* `load` function, do not extend `FileIO.load`!\nfunction load(f::File{format\"PNG\"})\n    open(f) do s\n        skipmagic(s)  # skip over the magic bytes\n        # You can just call the `load(::Stream)` method below...\n        ret = load(s)\n        # ...or implement everything here instead\n    end\nend\n\n# You can support streams and add keywords:\nfunction load(s::Stream{format\"PNG\"}; keywords...)\n    # s is already positioned after the magic bytes\n    # Do the stuff to read a PNG file\n    chunklength = read(s, UInt32)\n    ...\nend\n\nfunction save(f::File{format\"PNG\"}, data)\n    open(f, \"w\") do s\n        # Don't forget to write the magic bytes!\n        write(s, magic(format\"PNG\"))\n        # Do the rest of the stuff needed to save in PNG format\n    end\nend\n\nend # module MyFileFormat","category":"page"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"load(::File) and save(::File) should close any streams they open.  (If you use the do syntax, this happens for you automatically even if the code inside the do scope throws an error.) Conversely, load(::Stream) and save(::Stream) should not close the stream argument.","category":"page"},{"location":"implementing/#Implementing-streaming-I/O","page":"Implementing loaders/savers","title":"Implementing streaming I/O","text":"","category":"section"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"loadstreaming and savestreaming use the same query mechanism, but return a decoded stream that users can read or write. You should also implement a close method on your reader or writer type. Just like with load and save, if the user provided a filename, your close method should be responsible for closing any streams you opened in order to read or write the file. If you are given a Stream, your close method should only do the clean up for your reader or writer type, not close the stream.","category":"page"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"struct WAVReader\n    io::IO\n    ownstream::Bool\nend\n\nfunction Base.read(reader::WAVReader, frames::Int)\n    # read and decode audio samples from reader.io\nend\n\nfunction Base.close(reader::WAVReader)\n    # do whatever cleanup the reader needs\n    reader.ownstream && close(reader.io)\nend\n\n# FileIO has fallback functions that make these work using `do` syntax as well,\n# and will automatically call `close` on the returned object.\nloadstreaming(f::File{format\"WAV\"}) = WAVReader(open(f), true)\nloadstreaming(s::Stream{format\"WAV\"}) = WAVReader(s, false)","category":"page"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"If you choose to implement loadstreaming and savestreaming in your package, you can easily add save and load methods in the form of:","category":"page"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"function save(q::Formatted{format\"WAV\"}, data, args...; kwargs...)\n    savestreaming(q, args...; kwargs...) do stream\n        write(stream, data)\n    end\nend\n\nfunction load(q::Formatted{format\"WAV\"}, args...; kwargs...)\n    loadstreaming(q, args...; kwargs...) do stream\n        read(stream)\n    end\nend","category":"page"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"where Formatted is the abstract supertype of File and Stream.","category":"page"},{"location":"registry/#Registry-table","page":"Registry table","title":"Registry table","text":"","category":"section"},{"location":"registry/","page":"Registry table","title":"Registry table","text":"The following formats are registered with FileIO:","category":"page"},{"location":"registry/","page":"Registry table","title":"Registry table","text":"Format Name extensions IO library detection or magic number\nJLD .jld loads and saves on all platforms with JLD (UInt8[0x4a, 0x75, 0x6c, 0x69, 0x61, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x20, 0x28, 0x48, 0x44, 0x46, 0x35, 0x29, 0x2c, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x30, 0x2e, 0x30], UInt8[0x4a, 0x75, 0x6c, 0x69, 0x61, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x20, 0x28, 0x48, 0x44, 0x46, 0x35, 0x29, 0x2c, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x30, 0x2e, 0x31])\nJLD2 .jld2 loads and saves on all platforms with JLD2 (UInt8[0x4a, 0x75, 0x6c, 0x69, 0x61, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x20, 0x28, 0x48, 0x44, 0x46, 0x35, 0x29, 0x2c, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x30, 0x2e, 0x32], UInt8[0x48, 0x44, 0x46, 0x35, 0x2d, 0x62, 0x61, 0x73, 0x65, 0x64, 0x20, 0x4a, 0x75, 0x6c, 0x69, 0x61, 0x20, 0x44, 0x61, 0x74, 0x61, 0x20, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x2c, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20])\nGZIP .gz loads and saves on all platforms with Libz UInt8[0x1f, 0x8b]\nBSON .bson loads and saves on all platforms with BSON only extension\nJLSO .jlso loads and saves on all platforms with JLSO only extension\nRData .rda, .RData, .rdata loads with RData on all platforms has detection function\nRDataSingle .rds loads with RData on all platforms has detection function\nCSV .csv loads and saves on all platforms with CSVFiles only extension\nTSV .tsv loads and saves on all platforms with CSVFiles only extension\nFeather .feather loads and saves on all platforms with FeatherFiles \"FEA1\"\nExcel .xls, .xlsx loads and saves on all platforms with ExcelFiles only extension\nStata .dta loads with StatFiles on all platforms only extension\nSPSS .sav loads with StatFiles on all platforms \"FL2\"\nSAS .sas7bdat loads with StatFiles on all platforms UInt8[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc2, 0xea, 0x81, 0x60, 0xb3, 0x14, 0x11, 0xcf, 0xbd, 0x92, 0x08, 0x00, 0x09, 0xc7, 0x31, 0x8c, 0x18, 0x1f, 0x10, 0x11]\nParquet .parquet loads with ParquetFiles on all platforms \"PAR1\"\nPBMBinary .pbm loads and saves on all platforms with ImageIO \"P4\"\n  loads and saves on all platforms with Netpbm \n  loads and saves on all platforms with ImageMagick \nPGMBinary .pgm loads and saves on all platforms with ImageIO \"P5\"\n  loads and saves on all platforms with Netpbm \nPPMBinary .ppm loads and saves on all platforms with ImageIO \"P6\"\n  loads and saves on all platforms with Netpbm \nPBMText .pbm loads and saves on all platforms with ImageIO \"P1\"\n  loads and saves on all platforms with Netpbm \n  loads with ImageMagick on all platforms \nPGMText .pgm loads and saves on all platforms with ImageIO \"P2\"\n  loads and saves on all platforms with Netpbm \n  loads with ImageMagick on all platforms \nPPMText .ppm loads and saves on all platforms with ImageIO \"P3\"\n  loads and saves on all platforms with Netpbm \n  loads with ImageMagick on all platforms \nNRRD .nrrd, .nhdr loads and saves on all platforms with NRRD \"NRRD\"\nAndorSIF .sif loads with AndorSIF on all platforms \"Andor Technology Multi-Channel File\"\nFLO .flo loads and saves on all platforms with OpticalFlowUtils \"PIEH\"\nCRW .crw loads and saves on all platforms with ImageMagick UInt8[0x49, 0x49, 0x1a, 0x00, 0x00, 0x00, 0x48, 0x45]\nCUR .cur loads and saves on all platforms with ImageMagick UInt8[0x00, 0x00, 0x02, 0x00]\nDCX .dcx loads and saves on all platforms with ImageMagick UInt8[0xb1, 0x68, 0xde, 0x3a]\nDOT .dot loads and saves on all platforms with ImageMagick UInt8[0xd0, 0xcf, 0x11, 0xe0, 0xa1, 0xb1, 0x1a, 0xe1]\nEPS .eps loads and saves on all platforms with ImageMagick UInt8[0x25, 0x21, 0x50, 0x53, 0x2d, 0x41, 0x64, 0x6f]\n  saves with MimeWriter on all platforms \nHDR .hdr loads and saves on all platforms with ImageMagick UInt8[0x23, 0x3f, 0x52, 0x41, 0x44, 0x49, 0x41, 0x4e]\nICO .ico loads and saves on all platforms with ImageMagick UInt8[0x00, 0x00, 0x01, 0x00]\nINFO .info loads and saves on all platforms with ImageMagick UInt8[0x7a, 0x62, 0x65, 0x78]\nJP2 .jp2 loads and saves on all platforms with ImageMagick UInt8[0x00, 0x00, 0x00, 0x0c, 0x6a, 0x50, 0x20, 0x20]\nPDB .pdb loads and saves on all platforms with ImageMagick UInt8[0x73, 0x7a, 0x65, 0x7a]\nPDF .pdf loads and saves on all platforms with ImageMagick UInt8[0x25, 0x50, 0x44, 0x46]\n  saves with MimeWriter on all platforms \nPGM .pgm loads and saves on all platforms with ImageMagick UInt8[0x50, 0x35, 0x0a]\nPSD .psd loads and saves on all platforms with ImageMagick UInt8[0x38, 0x42, 0x50, 0x53]\nRGB .rgb loads and saves on all platforms with ImageMagick UInt8[0x01, 0xda, 0x01, 0x01, 0x00, 0x03]\nWMF .wmf loads and saves on all platforms with ImageMagick UInt8[0xd7, 0xcd, 0xc6, 0x9a]\nWPG .wpg loads and saves on all platforms with ImageMagick UInt8[0xff, 0x57, 0x50, 0x43]\nImagine .imagine loads and saves on all platforms with ImagineFormat \"IMAGINE\"\nTGA .tga loads and saves on all platforms with QuartzImageIO only extension\n  loads and saves on all platforms with ImageMagick \nGIF .gif loads and saves on all platforms with QuartzImageIO UInt8[0x47, 0x49, 0x46, 0x38]\n  loads and saves on all platforms with ImageMagick \nPNG .png loads and saves on all platforms with ImageIO UInt8[0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]\n  loads and saves on all platforms with QuartzImageIO \n  loads and saves on all platforms with ImageMagick \n  saves with MimeWriter on all platforms \nJPEG .jpeg, .jpg, .JPG loads and saves on all platforms with QuartzImageIO UInt8[0xff, 0xd8, 0xff]\n  loads and saves on all platforms with ImageMagick \nBMP .bmp loads and saves on all platforms with QuartzImageIO UInt8[0x42, 0x4d]\n  loads and saves on all platforms with ImageMagick \nPCX .pcx loads and saves on all platforms with ImageMagick (UInt8[0x0a, 0x02], UInt8[0x0a, 0x05])\nSVG .svg saves with MimeWriter on all platforms only extension\nOBJ .obj loads and saves on all platforms with MeshIO only extension\nPLY_ASCII .ply loads and saves on all platforms with MeshIO \"ply\\nformat ascii 1.0\"\nPLY_BINARY .ply loads and saves on all platforms with MeshIO \"ply\\nformat binary_little_endian 1.0\"\n2DM .2dm loads and saves on all platforms with MeshIO \"MESH2D\"\nOFF .off loads and saves on all platforms with MeshIO \"OFF\"\nMSH .msh loads and saves on all platforms with MeshIO only extension\nOUT .out loads and saves on all platforms with BundlerIO \"# Bundle file v0.3\\n\"\nGSLIB .gslib, .sgems loads and saves on all platforms with GslibIO only extension\nWAV .wav loads and saves on all platforms with WAV has detection function\nFLAC .flac loads and saves on all platforms with FLAC \"fLaC\"\nJLPROF .jlprof loads and saves on all platforms with FlameGraphs UInt8[0x4a, 0x4c, 0x50, 0x52, 0x4f, 0x46, 0x01, 0x00]\nbedGraph .bedgraph loads and saves on all platforms with BedgraphFiles has detection function\nTIFF .tiff, .tif loads and saves on all platforms with QuartzImageIO has detection function\n  loads and saves on all platforms with ImageMagick \nOMETIFF .tif, .tiff loads and saves on all platforms with OMETIFF has detection function\nAVI .avi loads and saves on all platforms with ImageMagick has detection function\nHDF5 .h5, .hdf5 loads and saves on all platforms with HDF5 has detection function\nSTL_ASCII .stl, .STL loads and saves on all platforms with MeshIO has detection function\nSTL_BINARY .stl, .STL loads and saves on all platforms with MeshIO has detection function\nFITS .fit, .fits, .fts, .FIT, .FITS, .FTS loads and saves on all platforms with FITSIO UInt8[0x53, 0x49, 0x4d, 0x50, 0x4c, 0x45, 0x20, 0x20, 0x3d, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x54]\nGadget2 .gadget2, .Gadget2, .GADGET2 loads and saves on all platforms with AstroIO has detection function\nRawArray .ra loads and saves on all platforms with RawArray UInt8[0x61, 0x72, 0x61, 0x77, 0x72, 0x72, 0x79, 0x61]\nMetaImage .mhd loads and saves on all platforms with MetaImageFormat \"ObjectType\"\nvegalite .vegalite loads and saves on all platforms with VegaLite only extension\nvega .vega loads and saves on all platforms with Vega only extension\n  saves with VegaLite on all platforms \nFCS .fcs loads and saves on all platforms with FCSFiles \"FCS\"\nHTML .html, .htm saves with MimeWriter on all platforms only extension","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [FileIO]\nPrivate = false","category":"page"},{"location":"reference/#FileIO.FileIO","page":"Reference","title":"FileIO.FileIO","text":"FileIO API (brief summary, see individual functions for more detail):\n\nformat\"PNG\": specifies a particular defined format\nFile{fmt} and Stream{fmt}: types of objects that declare that a resource has a particular format fmt\nload([filename|stream]): read data in formatted file, inferring the format\nload(File{format\"PNG\"}(filename)): specify the format manually\nloadstreaming([filename|stream]): similar to load, except that it returns an object that can be read from\nsave(filename, data...) for similar operations involving saving data\nsavestreaming([filename|stream]): similar to save, except that it returns an object that can be written to\nio = open(f::File, args...) opens a file\nio = stream(s::Stream) returns the IOStream from the query object s\nquery([filename|stream]): attempt to infer the format of filename\nunknown(q) returns true if a query can't be resolved\nskipmagic(io, fmt) sets the position of io to just after the magic bytes\nmagic(fmt) returns the magic bytes for format fmt\ninfo(fmt) returns (magic, extensions) for format fmt\nadd_format(fmt, magic, extension, libraries...): register a new format\nadd_loader(fmt, :Package): indicate that Package supports loading files of type fmt\nadd_saver(fmt, :Package): indicate that Package supports saving files of type fmt\n\n\n\n\n\n","category":"module"},{"location":"reference/#FileIO.DataFormat","page":"Reference","title":"FileIO.DataFormat","text":"DataFormat{sym}() indicates a known binary or text format of kind sym, where sym is always a symbol. For example, a .csv file might have DataFormat{:CSV}().\n\nAn easy way to write DataFormat{:CSV} is format\"CSV\".\n\n\n\n\n\n","category":"type"},{"location":"reference/#FileIO.File","page":"Reference","title":"FileIO.File","text":"File{fmt}(filename) indicates that filename is a file of known DataFormat fmt.  For example, File{format\"PNG\"}(filename) would indicate a PNG file.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FileIO.Stream","page":"Reference","title":"FileIO.Stream","text":"Stream{fmt}(io, filename=nothing) indicates that the stream io is written in known format DataFormat fmt. For example, Stream{format\"PNG\"}(io) would indicate PNG format. If known, the optional filename argument can be used to improve error messages, etc.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FileIO.add_format-Tuple{Type, Vararg{Any}}","page":"Reference","title":"FileIO.add_format","text":"add_format(fmt, magic, extension) registers a new DataFormat. For example:\n\nadd_format(format\"TIFF\", (UInt8[0x4d,0x4d,0x00,0x2b], UInt8[0x49,0x49,0x2a,0x00]), [\".tiff\", \".tif\"])\nadd_format(format\"PNG\", [0x89,0x50,0x4e,0x47,0x0d,0x0a,0x1a,0x0a], \".png\")\nadd_format(format\"NRRD\", \"NRRD\", [\".nrrd\",\".nhdr\"])\n\nNote that extensions, magic numbers, and format-identifiers are case-sensitive.\n\nYou can also specify particular packages that support the format with add_format(fmt, magic, extension, pkgspecifiers...), where example pkgspecifiers are:\n\nadd_format(fmt, magic, extension, [:PkgA=>UUID(...)])                     # only PkgA supports the format (load & save)\nadd_format(fmt, magic, extension, [:PkgA=>uuidA], [:PkgB=>uuidB])         # try PkgA first, but if it fails try PkgB\nadd_format(fmt, magic, extension, [:PkgA=>uuidA, LOAD], [:PkgB=>uuidB])   # try PkgA first for `load`, otherwise use PkgB\nadd_format(fmt, magic, extension, [:PkgA=>uuidA, OSX], [:PkgB=>uuidB])    # use PkgA on OSX, and PkgB otherwise\n\nThe uuids are all of type UUID and can be obtained from the package's Project.toml file.\n\nYou can combine LOAD, SAVE, OSX, Unix, Windows and Linux arbitrarily to narrow pkgspecifiers.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FileIO.add_loader","page":"Reference","title":"FileIO.add_loader","text":"add_loader(fmt, :Package=>uuid)\nadd_loader(fmt, [:Package=>uuid, specifiers...])\n\nDeclare that format fmt can be loaded with package :Package. Specifiers include OSX, Unix, Windows and Linux to restrict usage to particular operating systems.\n\nSee also add_format which can combine package support with the format declaration.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FileIO.add_saver","page":"Reference","title":"FileIO.add_saver","text":"add_saver(fmt, :Package=>uuid)\nadd_saver(fmt, [:Package=>uuid, specifiers...])\n\nDeclare that format fmt can be saved with package :Package. Specifiers include OSX, Unix, Windows and Linux to restrict usage to particular operating systems.\n\nSee also add_format which can combine package support with the format declaration.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FileIO.del_format-Tuple{Type}","page":"Reference","title":"FileIO.del_format","text":"del_format(fmt::DataFormat) deletes fmt from the format registry.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FileIO.file_extension-Tuple{File}","page":"Reference","title":"FileIO.file_extension","text":"file_extension(file) returns the file extension associated with File file.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FileIO.file_extension-Tuple{Stream}","page":"Reference","title":"FileIO.file_extension","text":"file_extension(file) returns a nullable-string for the file extension associated with Stream stream.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FileIO.filename-Tuple{File}","page":"Reference","title":"FileIO.filename","text":"filename(file) returns the filename associated with File file.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FileIO.filename-Tuple{Stream}","page":"Reference","title":"FileIO.filename","text":"filename(stream) returns a string of the filename associated with Stream stream, or nothing if there is no file associated.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FileIO.load","page":"Reference","title":"FileIO.load","text":"load(filename) loads the contents of a formatted file, trying to infer the format from filename and/or magic bytes in the file (see query).\nload(strm) loads from an IOStream or similar object. In this case, there is no filename extension, so we rely on the magic bytes for format identification.\nload(File{format\"PNG\"}(filename)) specifies the format directly, and bypasses the format query.\nload(Stream{format\"PNG\"}(io)) specifies the format directly, and bypasses the format query.\nload(f; options...) passes keyword arguments on to the loader.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FileIO.loadstreaming","page":"Reference","title":"FileIO.loadstreaming","text":"Some packages may implement a streaming API, where the contents of the file can be read in chunks and processed, rather than all at once. Reading from these higher-level streams should return a formatted object, like an image or chunk of video or audio.\n\nloadstreaming(filename) loads the contents of a formatted file, trying to infer the format from filename and/or magic bytes in the file. It returns a streaming type that can be read from in chunks, rather than loading the whole contents all at once.\nloadstreaming(strm) loads the stream from an IOStream or similar object. In this case, there is no filename extension, so we rely on the magic bytes for format identification.\nloadstreaming(File{format\"WAV\"}(filename)) specifies the format directly, and bypasses the format query.\nloadstreaming(Stream{format\"WAV\"}(io)) specifies the format directly, and bypasses the format query.\nloadstreaming(f; options...) passes keyword arguments on to the loader.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FileIO.magic-Tuple{Type}","page":"Reference","title":"FileIO.magic","text":"magic(fmt) returns the magic bytes of format fmt\n\n\n\n\n\n","category":"method"},{"location":"reference/#FileIO.query","page":"Reference","title":"FileIO.query","text":"query(io, [filename]) returns a Stream object with information about the format inferred from the magic bytes.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FileIO.query-Tuple{Any}","page":"Reference","title":"FileIO.query","text":"query(filename; checkfile=true)\n\nReturn a File object with information about the format inferred from the file's extension and/or magic bytes. If filename already exists, the file's magic bytes will take priority unless checkfile is false.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FileIO.save","page":"Reference","title":"FileIO.save","text":"save(filename, data...) saves the contents of a formatted file, trying to infer the format from filename.\nsave(Stream{format\"PNG\"}(io), data...) specifies the format directly, and bypasses the format query.\nsave(File{format\"PNG\"}(filename), data...) specifies the format directly, and bypasses the format query.\nsave(f, data...; options...) passes keyword arguments on to the saver.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FileIO.savestreaming","page":"Reference","title":"FileIO.savestreaming","text":"Some packages may implement a streaming API, where the contents of the file can be written in chunks, rather than all at once. These higher-level streams should accept formatted objects, like an image or chunk of video or audio.\n\nsavestreaming(filename, data...) saves the contents of a formatted file, trying to infer the format from filename.\nsavestreaming(File{format\"WAV\"}(filename)) specifies the format directly, and bypasses the format query.\nsavestreaming(Stream{format\"WAV\"}(io)) specifies the format directly, and bypasses the format query.\nsavestreaming(f, data...; options...) passes keyword arguments on to the saver.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FileIO.skipmagic-Tuple{Stream}","page":"Reference","title":"FileIO.skipmagic","text":"skipmagic(s::Stream) sets the position of s to be just after the magic bytes. For a plain IO object, you can use skipmagic(io, fmt).\n\n\n\n\n\n","category":"method"},{"location":"reference/#FileIO.stream-Tuple{Stream}","page":"Reference","title":"FileIO.stream","text":"stream(s) returns the stream associated with Stream s\n\n\n\n\n\n","category":"method"},{"location":"reference/#FileIO.unknown-Tuple{Union{Type, Formatted}}","page":"Reference","title":"FileIO.unknown","text":"unknown(f) returns true if the format of f is unknown.\n\n\n\n\n\n","category":"method"},{"location":"#FileIO.jl","page":"Home","title":"FileIO.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FileIO aims to provide a common framework for detecting file formats and dispatching to appropriate readers/writers.  The two core functions in this package are called load and save, and offer high-level support for formatted files (in contrast with julia's low-level read and write).  To avoid name conflicts, packages that provide support for standard file formats through functions named load and save are encouraged to register with FileIO.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install FileIO within Julia via","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\n\njulia> Pkg.add(\"FileIO\")`","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If your format has been registered, it might be as simple as","category":"page"},{"location":"","page":"Home","title":"Home","text":"using FileIO\nobj = load(filename)","category":"page"},{"location":"","page":"Home","title":"Home","text":"to read data from a formatted file. FileIO will attempt to find an installed package capable of reading filename; if no such package is found, it will suggest an appropriate package for you to add.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Likewise, saving might be as simple as","category":"page"},{"location":"","page":"Home","title":"Home","text":"save(filename, obj)","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you just want to inspect a file to determine its format, then","category":"page"},{"location":"","page":"Home","title":"Home","text":"file = query(filename)\ns = query(io)   # io is a stream","category":"page"},{"location":"","page":"Home","title":"Home","text":"will return a File or Stream object that also encodes the detected file format.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Sometimes you want to read or write files that are larger than your available memory, or might be an unknown or infinite length (e.g. reading an audio or video stream from a socket). In these cases it might not make sense to process the whole file at once, but instead process it a chunk at a time. For these situations FileIO provides the loadstreaming and savestreaming functions, which return an object that you can read or write, rather than the file data itself.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This would look something like:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using FileIO\naudio = loadstreaming(\"bigfile.wav\")\ntry\n    while !eof(audio)\n        chunk = read(audio, 4096) # read 4096 frames\n        # process the chunk\n    end\nfinally\n    close(audio)\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"or use do syntax to auto-close the stream:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using FileIO\nloadstreaming(\"bigfile.wav\") do audio\n    while !eof(audio)\n        chunk = read(audio, 4096) # read 4096 frames\n        # process the chunk\n    end\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that in these cases you may want to use read! with a pre-allocated buffer for maximum efficiency.","category":"page"},{"location":"#Supported-formats","page":"Home","title":"Supported formats","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The existing supported formats are summarized in the Registry table.","category":"page"},{"location":"#Supporting-new-formats","page":"Home","title":"Supporting new formats","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you want to extend FileIO's support for new formats, there are two separate steps:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Registering a new format with FileIO\nImplementing loaders/savers in your package","category":"page"},{"location":"","page":"Home","title":"Home","text":"These steps can be done in either order.","category":"page"},{"location":"registering/#Registering-a-new-format","page":"Registering a new format","title":"Registering a new format","text":"","category":"section"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"You register a new format by adding","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"add_format(fmt, magic, extension, libraries...)","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"to FileIO's registry. It's generally best if you experiment with this locally and make sure everything works before submitting a pull request. You'll need to pkg> dev FileIO to make the required changes.","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"Before going into detail explaining the arguments of add_format, here is a real example that could be used to register an I/O package for one of the Netpbm image formats:","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"add_format(format\"PPMBinary\", \"P6\", \".ppm\", [:Netpbm => UUID(\"f09324ee-3d7c-5217-9330-fc30815ba969\")]","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"Briefly, this indicates that files in this format typically have extension .ppm, the file contents typically start with \"P6\" (the byte sequence [0x50, 0x36]), and these files can be read and written by the Netpbm package. (The UUID is Julia's unique identifier for this registered package and can be obtained from the Project.toml file.)","category":"page"},{"location":"registering/#Argument-fmt","page":"Registering a new format","title":"Argument fmt","text":"","category":"section"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"fmt is a DataFormat type, most conveniently created as format\"IDENTIFIER\". If this file format has not previously been supported, you can make up IDENTIFIER yourself–there is no external standard, this is just a \"tag\" used internally by FileIO and its support routines. You should generally choose something that makes it easy to guess what format it refers to. Examples of some existing fmts are:","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"format\"PNG\": the format for png image files\nformat\"HDF5\": the format for hierachical data files v5","category":"page"},{"location":"registering/#Argument-magic","page":"Registering a new format","title":"Argument magic","text":"","category":"section"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"magic typically contains the magic bytes that identify the format. While file format can sometimes be guessed from the extension (e.g., \"pic.png\" would likely be a PNG image file), fundamentally the name of the file is something that can be changed by the user, so it may have no relationship to the content of the file. Moreover, there are many examples in which two or more different formats use the same extension, leading to ambiguity about the nature of the file. Is a .gbv file a Genie Timeline file or a PCB CAD file? Is that .fst file an audio file, a puzzle game file, or an R serialized dataframe file?","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"To identify the file uniquely, good format designers will include \"magic bytes\" as part of the content of the file to ensure that one can recognize or validate the format of the file. Typically, these magic bytes are the first bytes in the file, although there are many exceptions.","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"warning: Warning\nFormats that use common extensions (e.g., .out) and lack magic bytes cannot be registered with FileIO– permitting this would force us to choose one particular format above all others. In such cases, your package should provide its own I/O without using FileIO. To avoid name conflicts with FileIO, it may be best to avoid exporting names like load and save from your package; use module-qualifiers like MyPkg.load instead.","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"Some formats have multiple \"flavors\" of magic bytes (which might, for example, include a \"format version\" number); in such cases magic can be a list of byte sequences. In other cases, files cannot be identified by a specific set of bytes, but there's a pattern that can be exploited: magic can be a function that returns true or false depending on whether an I/O stream is consistent with the format.","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"Examples of magic bytes include:","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"GIF image files can have magic bytes corresponding to the ASCII characters in \"GIF87a\", i.e., [0x47, 0x49, 0x46, 0x38, 0x37, 0x61]. Alternatively, they might use \"GIF89a\", which signals a different version of the GIF format.\nPLY mesh files can come in two flavors, ASCII and binary. Their magic bytes are \"ply\\nformat ascii 1.0\" and \"ply\\nformat binary_little_endian 1.0\", respectively. These magic bytes are human-readable and span the first two lines of the file.\nBedGraph genomic data files do not have official magic bytes, but they do have a structure which can be fairly reliably recognized by a suitable detection function. (Though it would have made life far more straightforward if the creators of the format had just added some magic bytes!)","category":"page"},{"location":"registering/#Argument-extension","page":"Registering a new format","title":"Argument extension","text":"","category":"section"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"This can be a string or list of strings. Each should start with '.'.","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"Example: the Nearly Raw Raster Data format uses [\".nrrd\",\".nhdr\"].","category":"page"},{"location":"registering/#Argument-libraries","page":"Registering a new format","title":"Argument libraries","text":"","category":"section"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"This argument specifies the package or packages that can support input and/or output for the format. Each package specification should be of the form name => uuid, where name is the name of the package (encoded as a Symbol, e.g., :FeatherFiles) and uuid is the UUID from the package's Project.toml. The first-to-be listed package has highest priority; FileIO will try to use it to perform the requested operation, and move onto the next only if that fails. Failure might occur because the user does not have the package installed, or because the package's handler threw an error.","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"Some packages may only support specific forms of I/O, and can use LOAD and SAVE as specifiers for supported operations. Likewise, some packages rely on system libraries available only on certain platforms, and can include a platform specifier.","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"If your package isn't (yet) registered, you can alternatively specify the handler as the module itself.  In such cases, your call to add_format will likely be made from within your module or at the Julia REPL rather than in FileIO's registry. An exception is MimeWriter, a sub-module of FileIO that can write a few MIME formats.","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"Here's a real-world example (contained in FileIO's src/registry.jl) for PNG:","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"add_format(\n    format\"PNG\",\n    UInt8[0x89,0x50,0x4e,0x47,0x0d,0x0a,0x1a,0x0a],\n    \".png\",\n    [idImageIO],\n    [idQuartzImageIO, OSX],\n    [idImageMagick],\n    [MimeWriter, SAVE]\n)","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"idImageIO, idQuartzImageIO, and idImageMagic are name => uuid pairs for three different packages. QuartzImageIO is available only on macOS (OSX). The MimeWriter module (which is internally accessible to FileIO) only supports output (SAVE), not input.","category":"page"},{"location":"registering/#Examples","page":"Registering a new format","title":"Examples","text":"","category":"section"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"For further examples, users are encouraged to inspect FileIO's registry directly.","category":"page"}]
}
